Conclusions

* Lazy evaluation and how to use it to compute infinite data structures
* Distinction between computations and values
    * Random values computation giving values when you want
    * Signals computations where values can be derived
* Monads to abstract over properties of computation
* Running computations over time

Relationship between functional programming and mutable state.

How to encapsulate mutations:

* Laziness
* Functional Reactive Programming
* Monads

# Other topics

Concurrency

* Threads
* Actors
* Reactive streams
* Futures

Parallelism

* Parallel data structures
* Parallel algorithms

Distribution

* Distributed collections
* Data analysis
* Spark


